package ru.mail.littlerock2877.stepik.greedyAlgorithm;

import java.util.List;
import java.util.Scanner;
import java.util.ArrayList;

public class BigPolitics {
    /*Задача G. Большая политика
    В некотором королевстве есть N провинций. Король пожелал объединить все их под своей самодержавной властью. Естественно,
    чтобы никто не догадался об этих планах, он будет это делать поэтапно, а именно: раз в год он будет объединять какие-то две провинции в одну.
    Чтобы жителям обеих провинций не было обидно, новому территориальному образованию будет присвоено новое название, которое будет отличаться от обоих старых названий.
    Естественно, это потребует выпуска новых паспортов для жителей обеих провинций. Очевидно, что если в первой провинции pi жителей, а во второй - pj жителей,
    то для них надо выпустить pi + pj новых паспортов.

    На следующий год король объединяет еще какие-то две провинции. И так далее, до тех пор пока вся территория королевства не будет объединена в одну большую «провинцию».
    Определите, какое наименьшее количество новых паспортов придется выпустить, если король будет объединять провинции оптимально с этой точки зрения.

    Входные данные
    В первой строке вводится число N (натуральное, не превышает 10^5) – количество провинций. Затем вводится N чисел - количество жителей каждой провинции
    (натуральное, не превосходит 10^9.). Гарантируется, что изначально в королевстве хотя бы две провинции.

    Выходные данные
    Выведите единственное число - количество новых паспортов, которые придется выпустить.

    Sample Input 1:
    2
    2 6
    Sample Output 1:
    8
    Sample Input 2:
    3
    6 2 4
    Sample Output 2:
    18 */

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<Integer> arr = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            arr.add(scanner.nextInt());
        }
        int total = 0;
        for (int i = 0; i < n - 1; i++) {
            int min = 1000;
            int premin = 1000;
            for (int i1 : arr) {
                if (i1 < min) {
                    premin = min;
                    min = i1;
                } else if (i1 < premin) {
                    premin = i1;
                }
            }
            total += min + premin;
            arr.remove((Integer)min);
            arr.remove((Integer)premin);
            arr.add(min + premin);
        }
        System.out.println(total);
    }
}
